---
title: "Use Case 02"
author: Paolo Sonego
affiliation: https://github.com/onertipaday/rcompass
package: rcompass
abstract: > 
  Beyond basics
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Use Case 02}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteKeywords{Bioinformatics, Gene Expression, data}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

[VESPUCCI](https://vespucci.readthedocs.io/) is the gene expression database for grapevine and we can access it via its GraphQL interface, called [COMPASS](https://compass-.readthedocs.io/). The [rCOMPASS](https://onertipaday.github.io/rcompass/) package is a R package that wraps some functionalities to simplify communication with the COMPASS interface.

In this second exercise we will use [VESPUCCI](https://vespucci.readthedocs.io/) together with some dedicate R packages to create an integrated workflow that goes beyond the functionality that [VESPUCCI](https://vespucci.readthedocs.io/) alone provides.

The goal here is to answer the following question: *which are the "biological processes" that get shut down in fruit?*
To answer this question we will need to perform a GO enrichment analysis (using, e.g., [topGO](http://www.bioconductor.org/packages/release/bioc/html/topGO.html) package) on a subset of genes that are not expressed in fruit tissue.

For this case study we decide to use the TPM normalized values (databases.normalizations1="tpm") from VESPUCCI version 2.0 (versionNumber "2.0"). See `get_available_compendia()` function to check the 
different normalization available.

Let's start loading `rcompass`.

```{r}
# devtools::install_github("onertipaday/rcompass")
library(rcompass)
```

# Select the samples of interest

### Select berry samples
Using a SPARQL query we can select only the samples annotated as berry using the following triple template where [PO_0030108](http://www.ontobee.org/ontology/PO?iri=http://purl.obolibrary.org/obo/PO_0030108) is the [Plant Ontology](https://www.ebi.ac.uk/ols/ontologies/po) term for ***berry fruit***.

```{r}
sparql = "SELECT ?s ?p ?o WHERE { ?s <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://purl.obolibrary.org/obo/PO_0030108>}"

berry_samples <- get_sparql_annotation_triples(target = "sample", 
                                               normalization = "tpm", 
                                               query = sparql)[,1]
```

## Get the SampleSets
Now that we have the samples we need to retrieve the **SampleSets** objects for this specific normalization ('tpm' normalization).

```{r}
berry_ss <- get_sampleset_id(name_In = berry_samples, 
                             normalization = "tpm",
                             useIds = TRUE)
```

## Get the genes
We will need all genes

```{r}
genes <- get_biofeature_id(name_In = NULL)
```

## Create the module
Now that we have both the genes (**BiologicalFeatures**) and the **SampleSets**, we can create our **Module** and retrieve the TPM-normalized values.

```{r}
module <- create_module(compendium = "vespucci",
                        normalization = "tpm",
                        biofeaturesNames = genes$id, 
                        samplesetNames = berry_ss$id, 
                        useIds = TRUE)
colnames(module) <- berry_ss$name; row.names(module) <- genes$name
```

## Format the values
In order to better handle the module values and get rid of NaNs, we will create a data.frame starting from our Module values (we are using log2), with genes as rows and SampleSets as columns.

```{r format_module}
df_base <- module[rowSums(is.na(module)) != ncol(module), ] # remove rows with only NAs from the matrix
# substitute NA with row mean (not column mean as in zoo)
# df = log2(module + 0.01)
df = log2(df_base + 0.01)
i <- which(is.na(df), arr.ind = TRUE)
df[i] <- rowMeans(df[,-1], na.rm = TRUE)[i[,1]]
# colnames(df) <- berry_ss$name; row.names(df) <- genes$name
# df[is.nan.data.frame(df)] <- NA

module_df <- na.omit(df)

# is.nan.data.frame <- function(x)
# do.call(cbind, lapply(x, is.nan))
# df[is.nan.data.frame(df)] <- 0
#module_df <- df[!is.nan(df),]
# x_replace <- df
# x_replace[is.nan(x_replace)] <- 0  
# junk <- apply(as.data.frame(log2(module)), MARGIN = 2,function(x) replace(x, is.na(x), mean(x, na.rm = TRUE)))
#junk <- sapply(as.data.frame(module), function(x) replace(x, is.na(x), mean(x, na.rm = TRUE)))
#
# alternatively (much, much faster!)
# library(zoo)
# module_df <- zoo::na.aggregate(log2(module))
# module_df <- zoo::na.aggregate(log2(module),na.rm = TRUE)
# module_df2 <- log2(zoo::na.aggregate(module))
# or
# module_df2 <- imputeTS::na_mean(module)
# colnames(module_df) <- berry_ss$name; row.names(module_df) <- genes$name
hist(module_df, breaks = 100)
```

# Gaussian Mixture Model Analysis

## Fit a 2-component Gaussian Mixture Model
The idea to fit a 2-component Gaussian Mixture Model comes from the [following paper](https://www.embopress.org/doi/full/10.1038/msb.2011.28): Hebenstreit, D., Fang, M., Gu, M., Charoensawan, V., van Oudenaarden, A., & Teichmann, S. A. (2011). *RNA sequencing reveals two major classes of gene expression levels in metazoan cells*. Molecular systems biology, 7(1).


## Normal Mixture Models using mixtools package

```{r mixtools_fit_model}
suppressPackageStartupMessages(library(mixtools))
set.seed(42) 
gmm_fit <-  mixtools::normalmixEM(as.vector(module_df), k = 2)
```

### Plot the data distribution and the fitted model

```{r plot_mixtools}
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(plotmm))
plot_mm(gmm_fit, 2) +
  ggplot2::labs(title = "Berry samples Log2-TPM distribution",
                subtitle = "Mixtools Object", 
                x = "log2(TPM)",
                y = "Density(normalized)") + theme_minimal()
p <- plot_cut_point(gmm_fit, plot = TRUE, color = "amerika") + 
  ggplot2::labs(title = "Berry samples Log2-TPM distribution",
                subtitle = "Mixtools Object", 
                x = "log2(TPM)",
                y = "Density") + theme_minimal()
ggplotly(p)
```

### Choose a cutoff for non-expressed genes
From the plot we can (arbitrarily) choose a log2-TPM cutoff value to distinguish the portion of expressed genes from the non-expressed genes. We chose to set this cutoff at 0.5, that is roughly the median value of the lowly expressed component.

```{r}
# return the cut point value by setting plot = FALSE
(plot_cut_point(gmm_fit, plot = FALSE))
# genes with log2(tpm) < 0.5 in all samples
never_expressed_in_fruit <- apply(module_df, 1, function(x) all(x < 0.5))
table(apply(module_df, 1, function(x) all(x < 0.5)))
# percentage of genes not expressed in fruit
cat(length(names(never_expressed_in_fruit)[never_expressed_in_fruit])/(dim(module_df)[[1]]) * 100, "%")
```

# GO Analysis

## Retrieve the GO annotation
Now it's time to retrieve all the GO terms for our genes and see if in the subset of genes never expressed in fruit there are GO terms that are over-represented compared to the full annotation.

We might want to use the Annotation class to retrieve the annotation for all our genes filtering out the GO terms, but to avoid the overhead given by the large number of genes to use, it is better to perform a lower level operation and go directly with a SPARQL query for the annotation terms we are interested in.

```{r}
 get_annotation_triples(ids = genes$id[1:5])
```

So let's avoid the previous code that we ran for only 5 genes and go with the following instead, that is a SPARQL query that will return all the triples where a biofeature is annotated (Annotation is the term NCIT_C44272) with a term starting with 'GO_'


```{r}
sparql = "SELECT ?s ?o WHERE {?s <http://purl.obolibrary.org/obo/NCIT_C44272> ?o FILTER (strstarts(str(?o), 'GO_'))}"

triples <- get_sparql_annotation_triples(compendium = "vespucci",
                                         target = "biofeature", 
                                         normalization = "tpm",
                                         query = sparql)
colnames(triples) <- c("id","GOTERM")
triples$GOTERM <- stringr::str_replace(triples$GOTERM,"_",":")
```

Now let's create the association object required by goatools and get rid of the underscore '_' in the annotation terms and replace it with the ':' symbol.


```{r}
go_assoc <- dplyr::full_join(triples, genes)
```


## Setup the GO analysis
To start the GO analysis we will download the basic GO and the Plant Slim GO and create both DAGs objects.

```{r}
# goslim_url = 'http://current.geneontology.org/ontology/subsets/goslim_plant.obo'
# r = requests.get(goslim_url, allow_redirects=True)
# open('goslim_plant.obo', 'wb').write(r.content)
# oboslimdag = GODag("goslim_plant.obo")
# 
# obo_fname = download_go_basic_obo()
# obodag = GODag("go-basic.obo")
# Functional Enrichment Analysis (Gene Ontology)
# goslim_url = 'http://current.geneontology.org/ontology/subsets/goslim_plant.obo'
# GO_plant_slim <- read.table("/home/paolo/Dropbox/Lavoro/FEM/ClaudioMoser/ZerayeHaile/ANALYSIS/references/GO_plant_slim_fixed.tab", sep="\t", header=FALSE, stringsAsFactors=FALSE)
# colnames(GO_plant_slim)<-c("ID","GOTERM","GOdescription","Category")
# library("plyr")
# tmp <- dlply(GO_plant_slim,.(GOTERM))
# my_GO_ann_lib <- lapply(tmp, function(x){ subset(x, select=1, drop=TRUE) }) # drop=T ==> genes in a vector of characters
# or using
# library(magrittr)
# tmp <- GO_plant_slim %>% dlply(.(GOTERM))
# my_GO_ann_lib <- lapply(tmp, function(x){ subset(x, select=1, drop=TRUE) }) # drop=T ==> genes in a vector of characters
# library("topGO")
# geneID2GO <- inverseList(my_GO_ann_lib) # we need this object fot the annotation since there is no vitis.db
# geneNames <- names(geneID2GO) # As Universe I select all the genes in the genome
# head(geneNames)
# # ------------------------------------------------------------------------------
# myInterestingGenes <- as.character(scan("comuniInd_ripening.csv",w="ch"))
# geneList <- factor(as.integer(geneNames %in% myInterestingGenes))
# names(geneList) <- geneNames
# str(geneList)
```

## Prepare GOEnrichment study with the Plant Slim

```{r}
# study = GOEnrichmentStudyNS(
#         go_assoc['ALL'].keys(),
#         go_assoc,
#         oboslimdag,
#         propagate_counts = False,
#         alpha = 0.05,
#         methods = ['fdr_bh'])
```

Perform the enrichment analysis using our subset of genes and display the GO graph result

```{r}
# results_all = study.run_study(never_expressed_in_fruit, prt=None)
# goea_results_sig = [r for r in goea_results_all if r.p_fdr_bh < 0.05]
# plot_results("never_expressed_in_fruit_slim_{NS}.png", goea_results_sig)
# Image(filename='never_expressed_in_fruit_slim_BP.png')
```


Let's perform the same analysis but with the full GO DAG this time.

```{r}
# study = GOEnrichmentStudyNS(
#         go_assoc['ALL'].keys(),
#         go_assoc,
#         obodag,
#         propagate_counts = False,
#         alpha = 0.05,
#         methods = ['fdr_bh'])
# goea_results_all = study.run_study(never_expressed_in_fruit, prt=None)
# goea_results_sig = [r for r in goea_results_all if r.p_fdr_bh < 0.05]
# plot_results("never_expressed_in_fruit_complete_{NS}.png", goea_results_sig)
# Image(filename='never_expressed_in_fruit_complete_BP.png')
```


---

# GOFuncR

```{r}
library(GOfuncR)
```

### Custom annotations
Besides using bioconductor’s annotation packages for the mapping of genes to GO-categories, it is also possible to provide the annotations directly as a dataframe with two columns: (1) genes and (2) GO-IDs (parameter annotations).
```{r custom_annotation, results='hide'}
custom_anno <- go_assoc %>% transmute(gene = name, go_id=GOTERM)
## create input dataframe with candidate genes
gene_ids = sample(custom_anno$gene, size = 30, replace = FALSE)
input_hyper = data.frame(gene_ids, is_candidate=1)
input_hyper
## run enrichment analysis with custom annotations
res_hyper_anno = go_enrich(input_hyper, annotations=custom_anno)
```


```{r}
## first element of go_enrich result has the stats
stats = res_hyper_anno[[1]]
## top-GO categories
head(stats)
## top GO-categories per domain
by(stats, stats$ontology, head, n=3)
#all valid input genes
res_hyper_anno[[2]]

#The fourth element is a dataframe with the minimum p-values from the permutations, which are used to compute the FWER:

## minimum p-values from randomsets
head(res_hyper_anno[[4]])
```


```{r}
## hypergeometric test
# top_gos_hyper = res_hyper_anno[[1]][1:5, 'node_id']
# # GO-categories with a high proportion of candidate genes
# top_gos_hyper
# plot_anno_scores(res_hyper_anno, top_gos_hyper,annotations = go_assoc)
```


# Session information
```{r session information, echo=FALSE}
print(sessionInfo(), locale = FALSE)
```
